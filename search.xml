<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>证据理论</title>
    <url>/%E8%AF%81%E6%8D%AE%E7%90%86%E8%AE%BA.html</url>
    <content><![CDATA[<p>原文：<a href="https://en.wikipedia.org/wiki/Dempster%E2%80%93Shafer_theory" target="_blank" rel="noopener">Dempster–Shafer theory</a>;<br>    <a href="https://www.geeksforgeeks.org/ml-dampster-shafer-theory/" target="_blank" rel="noopener" title="ML | Dampster Shafer Theory">ML | Dampster Shafer Theory</a></p>
<p>信念函数理论，也被称为证据理论或Dempster-Shafer理论(DST)，是一个关于<strong>不确定性推理</strong>的一般框架，与其他框架如概率、可能性和不精确概率理论等都有一定的联系。该理论最初由Arthur P. Dempster 在统计推理的背景下提出，后来由Glenn Shafer发展成为一个用于建模<strong>认知不确定性</strong>的一般框架–一种证据的数学理论。该理论允许人们将不同来源的证据结合起来，并得出一个考虑到所有可用证据的信念程度（由一个称为信念函数的数学对象表示）。<br>从狭义上讲，Dempster-Shafer理论这个术语是指Dempster和Shafer提出的原始概念。然而，更常见的是在更广泛的意义上使用该术语，以适应特定类型的情况。特别是，许多作者提出了不同的证据组合规则，往往是为了更好地处理证据中的冲突。早期的贡献也是许多重要发展的起点，这些发展包括可转移信念模型和暗示理论。</p>
<p>Dempster Shafer理论是由Arthure P.Dempster在1967年和他的学生Glenn Shafer在1976年提出的。这个理论的提出是因为以下原因：</p>
<ol>
<li>贝叶斯理论只关注单一证据。</li>
<li>贝叶斯概率论不能描述无知。</li>
</ol>
<p>DST是一个证据理论，它综合了问题的所有可能的结果。因此，<strong>它被用来解决可能存在不同的证据会导致不同结果的问题</strong>。<br>这个模型中的不确定度是由以下信息给出的：</p>
<ol>
<li>考虑所有可能的结果。</li>
<li>通过提供一些证据，信念会导致相信某些可能性。</li>
<li>可行性将使证据与可能的结果相吻合。</li>
</ol>
<p>例子：<br>让我们考虑一个房间里有四个人，A、B、C、D（假设）突然熄灯，当灯再次亮起时，B因背部被刀子刺伤而死亡。没有人进入房间，也没有人离开房间，B也没有自杀。那么我们要找出凶手是谁？</p>
<p>要解决这些问题，有以下几种可能。</p>
<ol>
<li>{A}或{C}或{D}杀了他。</li>
<li>{A, C}或{C, D}或{A, C}都杀了他。</li>
<li>或者他们三个人杀了他，即{A、C、D}。</li>
<li>没有一个杀了他 {o}。</li>
</ol>
<p>这些都是我们可以通过这些证据来找到凶手的证据。<br>用上面的例子，我们可以这样说。<br>可能的结论集(P)： {p1, p2…..pn}<br>其中P是一组可能的结论，不能穷尽，意味着至少有一个(p)i必须为真。<br>(p)i必须是互斥的。<br>Power Set将包含2^n个元素，其中n是可能的集合中的元素数</p>
<p>例如：<br>如果P = { a, b, c}，那么Power set的值为<br>{o, {a}, {b}, {c}, {a, b}, {b, c}, {a, c}, {a, c}, {a, b, c}}}= 2^3个元素。</p>
<p><strong>Mass function m(K)</strong>。它是m({K或B})的解释，即，它意味着存在{K或B}的证据，而这些证据不能被K和B的更具体的信念所分割。</p>
<p>*<em>对K的信念Belief *</em>：Power Set 的元素K的信念是元素K的子集的质量之和。<br>假设K = {a, b, c}。<br>Bel(K) = m(a) + m(b) + m(c) + m(a, b) + m(a, b) + m(a, c) + m(b, c) + m(a, b, c)</p>
<p><strong>K中的可行性Plaausiblity</strong> ：它是与K相交的集的质量之和。<br>即；Pl(K)=m(a)+m(b)+m(c)+m(a，b)+m(b，c)+m(a，c)+m(a，b，c)</p>
<p>该理论的特点：</p>
<ol>
<li>它将忽略部分，使得所有事件概率合计为1。</li>
<li>在这个理论中，无知部分通过增加越来越多的证据来减少。</li>
<li>组合法则是用来组合各种类型的可能性。</li>
</ol>
<p>优点：</p>
<ul>
<li>当我们增加更多的信息，不确定性区间就会减少。</li>
<li>DST的无知程度更低。</li>
<li>Diagnose Hierarchies可以用它来表示。</li>
<li>处理这类问题的人，可以自由思考证据。</li>
</ul>
<p>缺点：<br>在这个计算中，由于我们必须处理2^n个集，所以计算的工作量很高。</p>
]]></content>
  </entry>
  <entry>
    <title>专家系统简介（二）</title>
    <url>/%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content><![CDATA[<p>原文：<a href="https://en.wikipedia.org/wiki/Expert_system#Disadvantages" target="_blank" rel="noopener">维基百科 Expert Systems</a></p>
<p>在人工智能中，专家系统是一种模拟人类专家决策能力的计算机系统。专家系统旨在通过知识体系的推理来解决复杂的问题，主要表现为if-then规则，而不是通过传统的过程代码。第一个专家系统是在20世纪70年代创建的，然后在20世纪80年代迅速发展起来。专家系统是第一批真正成功的人工智能(AI)软件。专家系统分为两个子系统:推理机子系统和知识库子系统。知识库表示事实和规则。推理引擎将规则应用于已知事实，以推断新的事实。推理引擎还可以包括解释和调试功能。</p>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><h2 id="早期发展"><a href="#早期发展" class="headerlink" title="早期发展"></a>早期发展</h2><p>20世纪40年代末至50年代初，现代计算机出现后不久，研究人员开始意识到这些机器对现代社会的巨大潜力。 最初的挑战之一是使这种机器能够像人类一样“思考”。 特别是，让这些机器能够像人类一样做出重要的决定。 医疗 / 保健领域提出了诱人的挑战，使这些机器作出医疗诊断决策。</p>
<p>因此，在20世纪50年代末，就在信息时代完全到来之后，研究人员开始试验使用计算机技术模拟人类决策的前景。 例如，生物医学研究人员开始为医学和生物学中的诊断应用创建计算机辅助系统。 这些早期诊断系统利用病人的症状和实验室检测结果作为输入，以产生诊断结果。 这些系统通常被描述为专家系统的早期形式。 然而，研究人员已经意识到，<strong>当使用传统的方法，例如流程图统计模式匹配，或概率论时，存在明显的局限性</strong>。</p>
<h2 id="正式的引入以及后续发展"><a href="#正式的引入以及后续发展" class="headerlink" title="正式的引入以及后续发展"></a>正式的引入以及后续发展</h2><p>这种情况逐渐导致了专家系统的发展，专家系统采用基于知识的方法。 这些医学专家系统是 MYCIN 专家系统 ，INTERNIST-I 专家系统 ，以及后来在20世纪80年代中期的 CADUCEUS。</p>
<p>专家系统在1965年左右由Edward Feigenbaum 领导的斯坦福启发式编程项目正式引入，他有时被称为“专家系统之父” ; 其他关键的早期贡献者是 Bruce Buchanan 和 Randall Davis。 斯坦福大学的研究人员试图确定<strong>哪些领域的专业知识具有高度的价值和复杂性</strong>，例如诊断传染病(Mycin)和识别未知的有机分子(Dendral)。 正如 Feigenbaum 所说，“<strong>智能系统的力量来自于它们所拥有的知识，而不是它们的具体形式和推理方案</strong>”这一观点在当时是一个重要的进步，因为过去的研究一直集中启发式计算方法上，最终在尝试开发非常通用的问题解决器(主要是Allen Newell和Herbert Simon的联合工作)。 专家系统成为人工智能(AI)软件的第一批真正成功的形式之一。</p>
<p>专家系统的研究在法国也很活跃。 在美国，研究的重点往往是基于规则的系统，首先是在 LISP 编程环境之上进行硬编码的系统，然后是 Intellicorp 等供应商开发的专家系统外壳。而在法国，研究的重点更多地放在了 Prolog 开发的系统上。 专家系统 shell 的优势在于，它们在某种程度上更容易为非程序员所使用。 Prolog 环境的优点是它们不仅仅关注 if-then 规则; Prolog 环境提供了一个更好的完整的一阶逻辑环境的实现。</p>
<p>在1980年代，专家系统激增。 大学提供了专家系统课程，世界五百强公司中有三分之二将这项技术应用于日常商业活动。日本的第五代计算机系统项目引起了国际关注，欧洲增加了研究经费。</p>
<p>1981年，IBM推出了第一台带有PC DOS操作系统的PC。个人电脑中功能相对强大的芯片的高可购性，与当时在企业IT界占主导地位的大型机中昂贵得多的处理能力成本之间的不平衡，创造了一种新的企业计算架构，称为客户机-服务器模型。计算和推理可以用PC大型机价格的一小部分来执行。这个模型还使业务单元能够绕过公司IT部门，直接构建自己的应用程序。因此，客户端服务器对专家系统市场产生了巨大的影响。专家系统在很多商业领域已经是异类，需要许多IT部门不具备、也不急于开发的新技能。它们很自然地适合于新的基于pc的shell，这些shell承诺将应用程序开发交付给最终用户和专家。在此之前，专家系统的主要开发环境一直是施乐(Xerox)、Symbolics和德州仪器(Texas Instruments)的高端Lisp计算机。随着PC和客户端服务器计算的兴起，Intellicorp和Inference Corporation等供应商将重点转移到开发基于PC的工具上。此外，通常由风险资本(如Aion Corporation、Neuron Data、Exsys和许多其他)资助的新供应商也开始定期出现。</p>
<p>最早用于大规模产品设计能力的专家系统是1982年开发的SID（整体设计综合）软件程序。SID用LISP编写，生成了93％的VAX 9000 CPU逻辑门。输入软件是由几位专家逻辑设计师创建的一组规则。 SID扩展了规则，并生成了规则本身大小很多倍的软件逻辑综合例程。 出乎意料的是，这些规则的组合导致整体设计超出了专家本身的能力，并且在许多情况下都优于同行。 尽管某些规则与其他规则相矛盾，但速度和面积的顶级控制参数提供了决胜局。 该程序极富争议性，但由于项目预算的限制，仍使用了该程序。 VAX 9000项目完成后，它被逻辑设计人员终止。</p>
<p>在20世纪70年代中期之前的几年里，人们对于专家系统在许多领域能够取得什么成就的期望往往是极其乐观的。 在这些早期研究的开始，研究人员希望开发完全自动的(即完全计算机化的)专家系统。 人们对计算机能做什么的期望往往过于理想化。 20世纪70年代早期，Richard M. Karp发表了他的突破性论文《组合问题中的可简化性》 ，从而彻底改变了这种状况。 由于Karp的工作，人们清楚地认识到，当一个人设计计算机算法时，有一定的局限性和可能性。 他的发现描述了计算机能做什么和不能做什么。 与这类专家系统相关的许多计算问题都存在一定的实用局限性。 这些发现为该领域的下一步发展奠定了基础。</p>
<p>在20世纪90年代及以后，专家系统这个术语和独立人工智能系统的概念大多从 IT 词典中消失了。 对此有两种解释。 一个是“专家系统失败了” : IT 世界继续前进，因为专家系统没有兑现他们过分夸大的承诺。 另一个恰恰相反，专家系统只是他们成功的受害者: 随着 IT 专业人员掌握了规则引擎等概念，这些工具从开发特殊用途专家系统的独立工具转变为许多标准工具之一。 许多主要的业务应用程序套件供应商(如 SAP、 Siebel 和 Oracle)将专家系统能力集成到他们的产品套件中，作为一种指定业务逻辑规则引擎的方式，不再仅仅用于定义专家将使用的规则，而是用于任何类型的复杂、不稳定和关键的业务逻辑; 它们通常与业务流程自动化和集成环境密切相关。</p>
<h2 id="专家系统的当前方法"><a href="#专家系统的当前方法" class="headerlink" title="专家系统的当前方法"></a>专家系统的当前方法</h2><p>先前类型的专家系统的局限性促使研究人员开发新的方法类型。 它们开发了更有效、更灵活和更有力的方法，以便模仿人类的决策过程。 研究人员开发的一些方法是基于人工智能(AI)的新方法，特别是机器学习和带有反馈机制的数据挖掘方法。 相关部分在“缺点”部分的讨论。</p>
<p>现代系统可以更容易地吸收新知识，从而更新自己。 这样的系统可以更好地从现有的知识中进行概括，并处理大量复杂的数据。 相关的是大数据的主题。 有时这种类型的专家系统被称为“智能系统”。</p>
<h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><p>专家系统是基于知识的系统的一个例子。 专家系统是第一个使用基于知识的架构的商业系统。 一个基于知识的系统实质上由两个子系统组成: 知识库和推理机。</p>
<p>知识库代表有关世界的事实。 在诸如Mycin和Dendral的早期专家系统中，这些事实主要表示为关于变量的断言。 在后来使用商业外壳开发的专家系统中，知识库采用了更多的结构，并使用了面向对象编程中的概念。 世界被表示为类，子类，实例和断言被对象实例的值代替。 规则通过查询和声明对象的值来工作。</p>
<p>推理引擎是一个自动推理系统，它评估知识库的当前状态，应用相关规则，然后将新知识断言到知识库中。 推理引擎还可以包括解释能力，以便它可以通过追溯导致断言的规则的触发，向用户解释用于得出特定结论的推理链。</p>
<p>推理引擎主要有两种模式：前向链接和后向链接。 不同的方法由推理引擎是由规则的先行（左手边）还是后继（右手边）驱动来决定。 在前向链接中，前一个条件会触发并声明结果。 例如，考虑以下规则：</p>
<img src="/%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%8C%EF%BC%89/rule.svg" class>

<p>前向链接的一个简单示例是将Man（Socrates）声明给系统，然后触发推理引擎。 它将匹配R1并将Mortal（Socrates）声明进入知识库。</p>
<p>向后链接不太直接。 在向后链接中，系统查看可能的结论，并向后工作以查看它们是否正确。 因此，如果系统试图确定Mortal（Socrates）是否为真，它将找到R1并查询知识库以查看Man（Socrates）是否为真。 专家系统外壳的早期创新之一是将推理引擎与用户界面集成在一起。 对于反向链接，此功能尤其强大。 如果系统需要知道一个特定的事实但不是必须知道，那么它可以简单地生成一个输入屏幕并询问用户是否知道该信息。 因此，在此示例中，它可以使用R1询问用户Socrates是否是Man，然后相应地使用该新信息。</p>
<p>使用规则来明确表示知识也可以使人们具有解释能力。 在上面的简单示例中，如果系统使用R1断言苏格拉底是凡人，并且用户希望了解苏格拉底是凡人的原因，那么他们可以查询系统，并且系统将回头查看引发该断言的规则，并提出这些规则向用户解释。 用户是否用英语询问“为什么苏格拉底是凡人？” 系统会回答“因为所有人都是凡人，而苏格拉底是人”。 一个重要的研究领域是用自然英语从知识库中生成解释，而不是简单地显示更正式但不太直观的规则。</p>
<p>随着专家系统的发展，许多新技术被集成到各种类型的推理引擎中。其中一些最重要的是：</p>
<ul>
<li>真相维护。 这些系统将依赖关系记录在知识库中，以便在事实被更改时，依赖项知识也可以相应地更改。 例如，如果系统得知苏格拉底不再是人，那么它将撤销苏格拉底是凡人的断言。</li>
<li>假设推理。 在这里，知识库可以被分成许多可能的视图，也就是世界。 这使得推理机可以同时探索多种可能性。 例如，系统可能想要探究这两个论断的结果，如果苏格拉底是一个人，那么什么是真的，如果他不是，那么什么是真的？</li>
<li>不确定性系统。 简单地使用规则表示知识的第一个扩展是将概率与每个规则关联起来。 所以，不是断言苏格拉底是凡人，而是断言苏格拉底可能是凡人，具有某种概率值。 简单概率在一些具有复杂机制的不确定推理系统中得到了扩展，如模糊逻辑和概率组合。</li>
<li>本体分类。 通过将对象类添加到知识库中，可以进行新型的推理。 除了简单地对对象值进行推理外，系统还可以对对象结构进行推理。 在这个简单的示例中，Man可以代表一个对象类，R1可以重新定义为定义所有人的类的规则。 这些类型的专用推理引擎称为分类器。 尽管分类器在专家系统中并未得到广泛使用，但它们对于非结构化的可变域非常强大，并且是Internet和新兴语义Web的关键技术。</li>
</ul>
<h1 id="专家系统的优缺点"><a href="#专家系统的优缺点" class="headerlink" title="专家系统的优缺点"></a>专家系统的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>知识推理系统的目标是使系统工作所需的关键信息显性化而不是隐性化。在传统的计算机程序中，逻辑被嵌入到代码中，通常只有 IT 专家才能审查这些代码。 使用专家系统的目标是以一种直观、易于理解、评审、甚至由领域专家而不是 IT 专家编辑的格式来指定规则。这种明确的知识表示方式的好处是快速开发和易于维护。</p>
<p>易于维护是最明显的好处。 这是通过两种方式实现的。 首先，通过消除编写常规代码的需要，使用专家系统就可以避免很多系统问题，这些问题通常是由对系统的很小改动引起的。 本质上，程序的逻辑流程（至少在最高级别）只是系统的给定条件，只需调用推理引擎即可。 这也是获得第二个好处的原因：快速成型。 使用专家级的系统外壳，可以输入一些规则，并能在几天之内开发出原型，而不是通常与复杂的IT项目相关的几个月或一年。</p>
<p>对专家系统外壳的一种说法是，它们消除了对训练有素的程序员的需求，而且专家可以自己开发系统。 事实上，这种情况很少发生。 虽然专家系统的规则比典型的计算机代码更容易理解，但是他们仍然有一个正式的语法，在那里一个错误的逗号或其他字符可能会像其他任何计算机语言一样造成混乱。 此外，随着专家系统从实验室中的原型转移到商业世界中的部署，集成和维护问题变得更加关键。 不可避免地需要与大型遗留数据库和系统集成并利用这些数据库和系统。 要做到这一点，集成需要与任何其他类型的系统相同的技能。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>学术文献中针对专家系统引用的最常见缺点是知识获取问题。 获取任何软件应用程序的领域专家的时间总是很困难，但是对于专家系统而言，这尤其困难，因为根据定义，专家的价值很高且组织不断需求。 由于这个问题，在后来的专家系统中，大量研究集中在知识获取工具上，以帮助自动化由专家定义的设计，调试和维护规则的过程。 但是，在查看专家系统在实际使用中的生命周期时，其他问题（基本上与任何其他大型系统的问题相同）似乎至少与知识获取同样重要：集成，访问大型数据库和性能。</p>
<p>性能可能特别成问题，因为早期的专家系统是使用工具(如早期的 Lisp 版本)构建的，这些工具解释代码表达式而不首先编译它们。 这提供了一个强大的开发环境，但其缺点是几乎不可能与最快的编译语言(如 c)的效率相匹配。 早期的专家系统很难集成系统和数据库，因为这些工具大多使用的语言和平台在大多数企业 IT 环境中既不熟悉也不受欢迎——例如 Lisp 和 Prolog 等编程语言，以及 Lisp 机器和个人计算机等硬件平台。 因此，在专家系统工具开发的后期阶段，许多工作都集中在与 COBOL 和大型数据库系统等遗留环境的集成，以及移植到更标准的平台上。 这些问题主要通过客户机-服务器模式的转变得到解决，因为个人电脑在 IT 环境中逐渐被接受为一个合法的平台，用于严肃的业务系统开发，而且价格合理的小型计算机服务器提供了人工智能应用程序所需的处理能力。</p>
<p>当知识库的规模增加时，专家系统的另一个主要挑战就出现了。 这会导致处理复杂性增加。 例如，当一个拥有1亿条规则的专家系统被设想为终极专家系统时，很明显，这样的系统将过于复杂，将面临太多的计算问题。 一个最高推理机必须能够处理大量的规则才能做出决定。</p>
<p>在规则太多的情况下，如何验证决策规则是否一致也是一个挑战。</p>
<p>还有一些问题涉及如何确定规则使用的优先次序以便更有效地运作，或者如何解决模糊性(例如，如果在一个规则中有太多的 else – if 子结构)等等。</p>
<p>其他问题涉及到在使用已知事实和试图概括到知识库中没有明确描述的其他情况时的过度拟合和过度概括效应。 这些问题也存在于采用机器学习方法的方法中。</p>
<p>与知识库相关的另一个问题是如何快速有效地更新其知识。 另外，如何添加一个新的知识点(也就是说，如何在许多规则中添加新的知识点)也是一个挑战。 在这方面，依赖于机器学习方法的现代方法更容易。</p>
<p>由于上述挑战，很明显，<strong>人工智能需要新的方法，而不是基于规则的技术。 这些新的方法是基于使用机器学习技术，并使用反馈机制</strong>。</p>
<p>医学专家系统(如果将计算机辅助诊断系统视为现代专家系统的话)以及其他应用领域中的关键挑战包括与以下方面有关的问题: 大数据、现有法规、医疗实践、各种算法问题和系统评估。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>Hayes-Roth将专家系统应用程序划分为10个类别，如下表所示。 示例应用程序不在原始的Hayes-Roth表中，其中一些随后出现。尽管这些类别提供了描述专家系统应用程序空间的直观框架，但它们并不是严格的类别，在某些情况下，应用程序可能会显示多个类别的特征。</p>
<img src="/%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%EF%BC%88%E4%BA%8C%EF%BC%89/application.png" class>

<p>Hearsay是通过专家系统方法解决语音识别问题的早期尝试。在大多数情况下，这类专家系统并不那么成功。Hearsay和所有的解释系统本质上都是模式识别系统——在嘈杂的数据中寻找模式。Hearsay识别音流中的音素。其他早期的例子是分析声纳数据来探测俄罗斯潜艇。这些类型的系统被证明更适合于神经网络AI解决方，和基于规则的方法相比。</p>
<p>CADUCEUS和MYCIN是医学诊断系统。用户向计算机描述他们的症状，就像他们向医生描述一样，计算机返回一个医学诊断。</p>
<p>Dendral是研究有机分子识别中假设形成的工具。它所解决的一般问题——设计一个给定一组约束的解决方案——是早期专家系统应用于业务领域最成功的领域之一，例如销售人员配置数字设备公司(DEC) VAX计算机和抵押贷款应用程序开发。</p>
<p>SMH.PAL是评估多残障学生的专家系统。</p>
<p>Mistral是用于监控大坝安全的专家系统，由Ismes（意大利）在1990年代开发。 它从自动监控系统获取数据并执行大坝状态诊断。 它的第一个副本安装在1992年的Ridracoli大坝（意大利）上，目前仍在24/7/365运行。 它已安装在意大利和国外的数个水坝上（例如，巴西的伊泰普水坝），并以Eydenet的名称在滑坡现场安装，并以Kaleidos的名称安装在古迹上。Mistral是CESI的注册商标。</p>
]]></content>
      <categories>
        <category>专家系统</category>
      </categories>
      <tags>
        <tag>专家系统</tag>
      </tags>
  </entry>
  <entry>
    <title>专家系统简介（一）</title>
    <url>/%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<p>原文：<a href="https://books.google.com/books/about/Expert_Systems.html?id=9-BQAAAAMAAJ" target="_blank" rel="noopener">Durkin, J.  Expert Systems: Design and Development</a></p>
<h1 id="智能的机器"><a href="#智能的机器" class="headerlink" title="智能的机器"></a>智能的机器</h1><p>一个国家的财富曾经来自于人民的劳动。几个世纪以来，这种财富受到了劳动力规模和体力的限制。随着工业革命的开始，出现了增加国家财富的新方向。以蒸汽和石油为燃料的机器被开发出来，以协助劳动密集型的工作，从而大大提高了生产力。历史告诉我们，今天的领先国家是那些较早接受这种技术的国家。</p>
<p>今天，国家财富来自于智力资源。 在科学、医学、商业和工程等不同领域拥有熟练人才的国家，会产生推动国家提高生活质量的创新。为了更好地利用这些资源，我们现在正在寻找新的机器，可以捕获这些人才的专业知识。 这种探索使我们进入了知识革命时代，寻找不是由蒸汽而是由知识驱动的机器。</p>
<p>这项努力的成功将为人类带来巨大的利益。 缺乏专业知识的国家可以使用这些机器来改善医疗水平，改进工程技术或提高生产效率。 公司可以使用它们来协助决策或在整个组织中扩散稀缺专家的技能。 研究人员还可以使用它们更好地了解人类的推理方式。 他们将在今天为我们服务，应对我们的精神挑战，并为发现明天的技术提供一种手段。</p>
<h1 id="对智能机器的追求"><a href="#对智能机器的追求" class="headerlink" title="对智能机器的追求"></a>对智能机器的追求</h1><p>对智能机器的神圣的追求并不是新的念头。 在过去的几个世纪中，人们一直在进行探索，部分原因是成功后带来的实际好处，另一部分则是对工作的热情。让我们简要回顾一下导致当前努力的这一探索的一些重点。</p>
<p>在1700年代后期和1800年代初期，一个小组在欧洲和美国巡回演出，展示了一种称为“国际象棋自动化”的设备，该设备的广告宣传是能够与人类同等地下棋。该设备装有一个装满齿轮和杠杆的盒子，但它里面却藏着一个当今最好的棋手之一。这个著名的骗局说明，早在早期，人们就对智能机器着迷。</p>
<p>1834年，Charles Babbage设计并开发了第一台机械计算机，称为“分析引擎”（McCorduck 1977）。该计算机可以进行数学计算并打印其结果。 Babbage建议进一步开发该机器以使其能够下棋，并认为这种机器可能会与人类竞争。 由于当时人们对一台机器可以与人类进行智力竞争而持怀疑态度，因此他从未进行过这项提议的工作——当今许多人都对智能计算机持相同的看法。</p>
<p>直到本世纪上半叶。 对智能机器的渴望仍然是一个遥不可及的梦想，一个等待技术追赶的梦想。 使这一梦想成为现实的技术是随着计算机的发展而出现的。</p>
<p>早期的计算机是高速数据处理器，使用编写的程序按照规定的算法执行一系列任务。 编写程序解决方程式，处理数据列表，或扫描数据库搜索所需的信息。 然而，尽管他们能够处理数据，但是他们不能对提供给他们的信息进行推理。 需要人类推理的问题留给了人类。</p>
<p>转折点出现在研究人员开始将有关问题的<strong>知识</strong>编码输入计算机的时候。 问题的事实、规则和结构以“符号”的形式被编码到计算机中。 符号是简单的字母数字字符，我们可以用来表示问题知识的片断。 新的符号处理语言也被开发出来，如 LISP 和 PROLOG，它们可以通过符号信息进行编码和搜索。</p>
<p>利用符号知识表示和搜索方法以及符号编程语言，研究人员致力于开发表现出智能行为的程序。 对智能机器的探索发现了一个不同的方向，一个叫做人工智能的新研究领域诞生了。</p>
<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><p>1956年，一小群计算机科学家参加了由 IBM 赞助的达特茅斯学院的夏季研讨会。 他们的讨论集中在他们目前在自动定理证明和新的编程语言的研究成果。 他们还讨论了如何将这项工作用于开发能够模拟人类推理的计算机。 这次会议标志着人工智能的诞生。</p>
<blockquote class="blockquote-center"><p>A field of study in computer science that pursues the goal of making a computer reason in a manner similar to humans. </p>
</blockquote>

<p>人工智能(AI)是一个令人生畏的术语。 它给我们带来的形象，就像工业革命时期轧棉机对农场工人的威胁一样。 害怕被具有优越动力的自动化机器取代的恐惧，现在已经被焦虑所取代，焦虑的原因是机器可能会丧失我们人类的基本特征—- 我们的智能。 然而，当我们透过这个令人担忧的标签去看这个领域是关于什么的时候，一幅远不那么不祥的画面被描绘了出来。</p>
<p>在最简单的意义上，AI 是研究开发能展现人类智能的计算机程序。 这代表了一个抽象和难以捉摸的目标，因为甚至很难定义智力。 能力强的推理能力是衡量人类智力的一个标准，但是一个人在某个特定主题上的知识代表了另一个标准。</p>
<p>从实用的角度来看，人工智能的目标是使计算机对人类更有用。 这可以通过编写计算机程序来帮助人们做决策，智能信息搜索，或者简单地通过自然语言界面使计算机更容易使用来实现。 AI的第二个目标也同样重要，那就是更好地理解人类的智慧。 构建一个智能计算机系统需要我们了解人类在解决问题时是如何获取、组织和使用知识的。</p>
<h1 id="专家系统"><a href="#专家系统" class="headerlink" title="专家系统"></a>专家系统</h1><p>专家系统领域的早期阶段得到了从 AI 和 DENDRAL 工作中学到的两个主要经验教训的帮助。 首先是在程序中对丰富的知识资源进行编码的重要性。 人们现在认识到，通用推理技术的局限性太大，无法解决实际问题。 第二个教训与系统知识的范围有关。 针对重点突出的问题设计的系统比针对广泛问题的系统运行得好得多。</p>
<p>在构建专家系统时，这两个经验教训自然会将我们引向一个来源: 一个问题专家。 专家是一个对问题有着卓越理解的个体。 通过经验，专家发展的技能，使他或她有效和高效率地解决问题。 我们的工作是在我们的专家系统中“克隆”这个专家。</p>
<blockquote class="blockquote-center"><p>A computer program designed to model the problem-solving ability of human expert. </p>
</blockquote>

<p>我们试图在我们的系统中建立专家的两个主要特征: 专家的知识和推理。 要做到这一点，系统必须有两个主要模块: 一个知识库和一个推理机。 这个专家系统的简单视图如图1.1所示。</p>
<div style="width:60%;margin:auto"><img src="/%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89/expertsytem1.png" class></div>

<p>知识库包含专家提供的关于问题领域的高度专门知识。 它包括问题事实、规则、概念和关系。 例如，它可能包含医生提供的诊断血液疾病的知识，投资顾问提供的投资组合规划知识，或者石油工程师提供的解释勘探地球物理学数据的知识。 我们如何在知识库中编码这些知识是知识表示的主题，将在第3章中介绍。</p>
<p>推理机是知识处理器，是在专家推理的基础上建模的。 引擎利用给定问题的可用信息，再加上存储在知识库中的知识，得出结论或建议。 我们如何设计这个引擎是推理技术的主题，将在第4章中介绍。 下一章将向您介绍有关专家系统操作的更多细节。</p>
<h1 id="为什么要建立专家系统"><a href="#为什么要建立专家系统" class="headerlink" title="为什么要建立专家系统"></a>为什么要建立专家系统</h1><p>专家对任何组织来说都是宝贵的资源。 他们可以提供创造性的想法，解决困难的问题，或有效地执行日常任务。 他们的贡献可以提高组织的生产力，这反过来可以提高其在市场中的竞争地位。 但是在一个专家系统中捕获这种天赋的价值是什么呢？ 我们回答这个问题的一种方法是将专家系统与人类专家进行比较，如表1.1所示。</p>
<div style="width:70%;margin:auto"><img src="/%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89/expertsytem2.png" class></div>

<p>就像任何机器一样。 一个专家系统在完成专家的工作日之后，还可以继续工作。 就像任何电脑程序一样。 我们可以便宜地复制它，然后把它分散到缺乏专家才能的地方。 我们也可以将我们的系统送入恶劣的环境，我们可以在晚上睡得香甜，因为我们知道我们系统技能的来源不会受到伤害。</p>
<p>人类的专业知识是容易消逝的。 通过死亡、退休或工作调动，一个组织可能会失去专家的才能。 一旦在专家系统中捕获，组织就保留了这种专业知识，允许继续提供支持。 组织还可以在培训中使用该系统，将专门知识传授给新手。</p>
<p>专家系统比人类专家产生的结果更加一致。 人类的决策受到许多可能影响绩效的因素的影响。 例如，个人问题可能会占据专家的注意力，从而阻碍生产结果的产生。 在紧急情况下，专家可能会因为时间压力或紧张而忘记一些重要的知识。 在这个1和0的非情感世界里，专家系统不受这些干扰的影响。</p>
<p>专家解决问题的速度也受到许多因素的影响。 相比之下，专家系统以一致的速度执行，并且在许多情况下，可以比专家更快地执行任务。 例如，开发了一个称为 CCH 的专家系统，以协助为服装行业的信用结算所(Jambor，R. er al. 1991)给予客户信用评级和具体美元的信用限额建议。 该系统在10秒内处理一个应用程序，这个任务以前需要3天才能完成。</p>
<p>人类专家往往是昂贵的。 他们要求很高的工资或服务费，并且由于他们的稀缺性，很容易得到他们的要求。 相比之下，专家系统相对便宜。 开发成本可能很高，但在许多情况下，可以在系统部署后迅速恢复。 例如，开发了一个称为 AUTHORIZER’s ASSISTANT (AA)的专家系统，以帮助处理美国运通的信用卡申请(Rothi 和 Yen 1990)。 它帮助信用授权者对12个数据库进行排序，以确定是否批准个人收费。 该系统缩短了处理信用卡客户购买授权请求所需的时间，最大限度地减少了不良信用决策造成的损失，并提高了人工授权者的整体业务性能。 美国运通公司发现，使用该系统后，生产率提高了20% ，两年内就能收回成本。</p>
<p>从表1的比较中可见。 我们想要建立一个专家系统有两个一般的原因: <strong>替换专家或者助理专家</strong>。 在对专家系统文献进行的调查中(本章后面将详细讨论) ，这两个原因似乎也是报告开发系统的大多数组织的动机。 接下来的几个部分将讨论每个领域，并提供示例系统的简要描述。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在过去的几十年里（书本出版于1994年），我们已经看到了一项技术的成熟，从实验性的好奇心变成了一个有价值的工具，用于帮助人类决策。 我们见证了它在广泛的任务中的应用: 从帮助矿井管理人员规划采矿活动，帮助农民避免虫害，到控制空间站上的生命支持系统。 无论如何，我们发现这项技术成功的主要原因在于商业领域。 在当今高度竞争的商业环境中，组织意识到良好的决策很快就会转化为利润。 如本章所示，许多业务组织已经认识到专家系统的潜力，并将其用于日常使用。 正如工业革命的历史告诉我们的那样，那些具有迅速采用有前途的新技术的洞察力的人，往往是后来发展最快的人。 也许有一天，我们可以追溯到明天的成功，从而导致今天的组织决定拥抱专家系统——只有在童话故事中，我们才能看到乌龟击败野兔。<br>本章的主要经验教训是:</p>
<ul>
<li>专家系统技术是人类探索智能机器历史的现阶段。</li>
<li>专家系统建模了人类专家的问题解决能力。</li>
<li>专家系统在广泛的应用领域得到了发展。</li>
<li>在过去十年中，专家系统的增长速度是几何级数。</li>
</ul>
]]></content>
      <categories>
        <category>专家系统</category>
      </categories>
      <tags>
        <tag>专家系统</tag>
      </tags>
  </entry>
  <entry>
    <title>如何构建一个专家系统</title>
    <url>/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%93%E5%AE%B6%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<p>原文：<a href="https://engineering.purdue.edu/~engelb/abe565/es.htm" target="_blank" rel="noopener">Building Expert Systems</a></p>
<p>本文探讨专家系统（ES）的开发。 本文中包含的许多材料摘自：Jones, D.D. and J.R. Barrett. 1989. Building expert systems. In J.R. Barrett and D.D. Jones (eds). Knowledge Engineering in Agriculture. ASAE Monograph No. 8, ASAE, St. Joseph, MI.</p>
<h1 id="何时使用专家系统"><a href="#何时使用专家系统" class="headerlink" title="何时使用专家系统"></a>何时使用专家系统</h1><p>ES并不适合所有类型的问题。 最初，许多开发人员积极寻求适合ES解决方案的问题，或者试图解决使用ES遇到的所有问题。 随着经验的积累，<strong>注意力已经更加集中在要解决的问题上</strong>，而不是解决方法上。 请注意，在本课程中，我们专注于系统工程技术和工具，因此已经并且将非常关注解决方案技术。</p>
<p>一些问题可以用现有的算法来描述，或者用统计评估方法来描述。 其他定义不明确、结构不良、目前需要人类专家帮助的问题，可以使用专家系统适当地解决。 实际上，这些技术正在迅速地与模拟和其他常规编程一起成为解决各种问题的重要工具。 <strong>信息的不完全性</strong>是适合于用专家系统解决的问题的特征。</p>
<p>“<strong>电话测试</strong>”通常可以用来帮助确定一个用传统方法无法轻易解决的问题是否适合 ES 解决方案。 如果领域专家可以通过与终端用户的电话交换机解决问题，那么也许可以开发专家系统程序来解决这个问题。 另一方面，如果使用者不能口头描述问题，或者如果专家不能在电话访谈的基础上一致地得出一个合理的解决方案，那么专家系统的发展很可能不令人满意。 电话测试确保专家不会从其他感官获得有关问题的额外信息，并确保使用者能够用<strong>语言</strong>充分描述问题(这一点很重要，因为专家服务的使用者需要充分描述问题)。</p>
<h1 id="ES开发步骤"><a href="#ES开发步骤" class="headerlink" title="ES开发步骤"></a>ES开发步骤</h1><p>如果一个 ES 解决方案是适当的，那么人们应该以一种系统的方式来处理开发，就像本学期前面讨论的系统方法步骤和模型开发步骤一样。 这个过程在很大程度上是一个原型的改进和扩展。 随着组织和代表性的改善，知识基础的深度和广度都有所增加，同时有助于指导后续的发展阶段。 原型成为进一步开发的基础，无论是精炼还是丢弃，还是重新启动过程。 它有助于确定哪些方法最有价值，哪些方法应当摒弃。 这些决策可以尽早做出，从而将开发成本降到最低。</p>
<p>快速原型设计可以让我们对完成的产品有一个大致的了解。在任何项目中，沟通和跟踪进度都是非常重要的，这不仅对资助机构和主管人员很重要，对那些对充分利用宝贵时间感兴趣的领域专家也很重要。原型应该是可记录的进度指标。与传统的编程方法相比，这是ES的主要优势。</p>
<p>有几种开发专家系统的一般方法被提出。Waterman (1986)提出了最广泛接受的方法:</p>
<ol>
<li>Identification 识别</li>
<li>Conceptualization 概念化</li>
<li>Formalization 形式化</li>
<li>Implementation 实施</li>
<li>Testing 测试</li>
</ol>
<p>这些阶段是高度相关和相互依存的。 迭代过程一直持续下去，直到软件始终在可接受的水平上执行。 注意，上面的步骤基本上是那些<a href="https://engineering.purdue.edu/~engelb/abe565/week2.htm#model%20development%20steps" target="_blank" rel="noopener">模型开发</a>和<a href="https://engineering.purdue.edu/~engelb/abe565/sysanal.htm" target="_blank" rel="noopener">系统分析方法</a>。</p>
<h2 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h2><p>识别是传统软件开发中进行的需求分析步骤。 它包括一个正式的任务分析，以确定外部需求、输入和输出的形式、程序将被使用的设置以及确定用户(非常重要!)。在这个阶段，需要清楚地确定参与者、问题、目标、资源、费用和时间框架。</p>
<p>参与者是赞助这项工作的小组、领域专家和知识工程师。 选择一个合适的领域专家对于项目的成功至关重要。 领域专家应该是主题领域的合法权威，因为软件必须拥有高质量的知识，这个人必须有时间和兴趣致力于项目。 不仅需要专家的个人承诺，而且还需要雇主的行政支持，以解除个人的某些现有职责。开发并不是小事，特别是当试图在一个已经全职工作分配的基础上。</p>
<p>虽然使用人类领域专家是典型的开发方法，但应该指出的是，有几个成功的方案仅使用参考材料，或者只有最少的人类领域专家参与。 这可能看起来与公认的 ES 定义或多或少相矛盾，然而，这些程序确实利用了编程技术，如反向链接来查找程序参数值，解释程序逻辑等。 一个第一手的专家本身是否必须存在，或者一个知识的解释者是否足够，这都是主观的。 不依赖专家的程序通常被称为知识推理系统系统、知识系统或基于规则的系统。</p>
<p>大多数这些解释都是数据库查询，用于加强查找厚厚的参考手册中的相关信息，例如杂草或化学信息，或者也许用于查找大型诊断手册中的具体信息。 可以说，不仅在编写最初的参考资料方面，而且在将资料转化为解决问题或回答问题所需的格式和顺序方面具有专门知识的程序员也参与了大量的人力专门知识。 随着AI研究人员开创的知识工程技术与常规编程语言一起被集成到程序和数据库管理软件中，传统专家系统开发过程的定义将继续模糊不清。</p>
<p>为了证明开发的时间和成本的合理性，这个问题对于一个供资组织来说必须是重要的，并且必须有明确的定义。 虽然开发人员不能忽视问题和其他主题领域之间的相互作用，但是应该努力限制问题领域，使程序的建议具体而有价值，而不是一般的教育性。 <strong>选择深度而不是广度</strong>不仅使程序更加强大和有用，而且通过最小化在推荐之前必须从用户那里获得的信息量，使程序更加高效。 例如，对于有大豆害虫问题的用户来说，运行一个处理大豆害虫的程序比运行一个处理大豆生产的程序更有效率。</p>
<p>软件的具体目标或用途必须被所有各方接受。 目标不仅仅是解决问题。 必须仔细考虑最终用户的背景和需要。</p>
<p>尽管一个设计得当的用户界面看起来非常重要和显而易见，但它却常常被忽视。 通常，完成知识库的努力是如此困难和费时，开发人员几乎没有精力留给用户界面。</p>
<p>资金和时间是需要考虑的主要资源。 需要确定的其他资源包括知识来源、计算机硬件和开发软件。 与所有的编程项目一样，这些估计是困难的，但是它们必须是现实的。 预算成本应包括专家和程序员损失的生产力成本，他们将投入时间进行工作，并且不断维护知识库。 同样，预期收益必须包括对未来几年节省的宝贵时间的估计。</p>
<p>应该对程序的使用寿命进行一些估算。 其他问题包括需要多长时间使用一次专业知识，解决问题的替代方法的成本和可用性以及工作场所中可能的可接受性。 对成本和收益的真实评估可以帮助确定合理的计划细节水平。</p>
<p>可用的硬件可以极大地影响用于开发的计算机的选择，因为开发人员必须确定帮助消息的范围、图形、问题的形式、输出的范围和格式以及与其他程序和数据库交互的需要。许多故障排除和分类问题需要根据环境的感官检查结果(视觉、嗅觉、感觉等)输入。</p>
<p>高分辨率彩色图形在农业故障排除或分类应用中特别有用。 应使用高质量，廉价的PC图形以及高分辨率彩色扫描仪和视频捕获设备，以有利于减少用户在回答程序提出的问题或解释程序输出时可能出现的混乱。 最终用户对计算机硬件和软件的经验越少，在设计用户与机器接口时就必须付出更多的努力。 ES具有比常规程序更透明（程序流可以按需提供给用户）的优点，如果用户可能对“黑匣子”计算机输出持怀疑态度，则应利用此能力。</p>
<h2 id="概念化"><a href="#概念化" class="headerlink" title="概念化"></a>概念化</h2><p>专家系统开发的第二阶段，概念化，包括设计提议的程序（the proposed program），以确保理解和定义问题领域中的特定交互和关系。 确定了对象和过程以及控制机制之间的关键概念和关系。 这是知识获取的初始阶段。 它涉及到情境的具体角色塑造和决定解决问题所需的专业知识。</p>
<p>知识工程师可以使用以下问题来帮助理解专家的工作:</p>
<ul>
<li>专家究竟做了什么决定？</li>
<li>决定导致的结果是什么？</li>
<li>哪些结果需要更多的反思、探索或互动？ </li>
<li>达成决定需要哪些资源或投入？</li>
<li>当决定一个特定的结果时，存在什么样的条件？</li>
<li>这些条件如何一致地预测一个给定的结果? </li>
<li>在接触到有影响力的输入之后的什么时候做出决定？</li>
<li>给出具体案例的细节，知识工程团队的预测结果是否与专家的预测结果一致？</li>
</ul>
<p>使用几种知识获取方法中的一种或几种知识获取方法的组合。 知识获取模块中提供更多详细信息。</p>
<p>典型的做法是确定最终用户可能向领域专家提出的问题以及可能的解决办法的范围。 开始的一个方法是从一系列最终建议开始，然后<strong>建立通向这些建议的路径</strong>。 例如，在动物生产设施环境故障排除的ES开发中(例子中作了简化) ，最高级别的编程可能包括以下典型的症状和建议:</p>
<ol>
<li>动物太冷== &gt;添加绝缘和/或空间加热器</li>
<li>高湿度== &gt;增加空间加热器和/或增加通风率</li>
<li>动物太热== &gt;增加通风和/或增加绝缘和/或减少动物密度</li>
</ol>
<p>超过这一点的开发过程主要是在顶层就位后对细节进行细化和添加的过程。 例如，在上面的第一条中，将添加额外的信息，以帮助确定“动物太冷”的假设是否属实。 这并不像表面上看起来那么简单，因为单凭建筑物的温度并不能准确地衡量动物的舒适度。 其他考虑因素包括地板是否干燥和铺设良好、使用的地板材料、建筑物是否通风、动物倾向于呆在围栏的什么地方、建筑物内的所有动物是否都有类似的症状，或者这个问题是否只是各例，动物是伸展开还是紧挨着挤在一起，毛发是平放还是竖着，或者它们是否明显在颤抖。</p>
<p>此外，还需要更多的细节来确定具体的补救措施。 第一项的最终建议将取决于问题的答案，这些问题能否证明动物太冷的假设，如果动物太冷，原因是什么。 例如，如果确定建筑物的隔热程度较低，最终建议将取决于饲养动物的类型和年龄、夏季和冬季的气候条件、动物是否会与包含隔热材料的墙体有物理接触，以及国家和地方建筑法规和防火规范。 同样，推荐的加热器类型取决于饲养动物的类型和年龄、建筑物的类型和条件、当地法规、可用燃料的类型和成本、气候条件、所使用的通风系统类型等。 可以看出，知识库在这个提炼过程中不断发展，以提供与人类专家提出的建议同样准确的建议。</p>
<p>知识工程师的工作是确定领域专家在提出具体建议时所需的知识来源，即确定需要查阅的参考书、需要进行的计算(或执行的其他计算机程序)以及需要采用哪些经验法则(启发法)。 用户可能不知道的信息应该通过额外的规则或其他知识结构来确定和表示。 然后可以从用户或创建的其他规则中获得应用这些规则所需的附加信息。 这种结构通常是通过与领域专家频繁和密集的访谈创建的。</p>
<p>应该寻找机会对知识进行分组、排序。例如，在通风问题中，一旦专家知道饲养的动物正在分娩或哺乳，他就会自动丢弃处理较大动物的大部分知识库，从而缩小搜索空间。通常情况下，专家在每次与知识工程师的访谈中都会被呈现3-5个潜在的问题场景，知识工程师以最终用户的身份出现，也可能是一个好奇的用户，不断地询问专家问题的目的和他的答案的详细理由。这有点像一个坚持不懈的孩子在问为什么。</p>
<p>收集到的信息经过分析，构成了将在下一次会议上与专家一起介绍的情景的基础。 正确和完整地描述专家的问题解决逻辑是困难的，因为真正的<strong>专家通常不知道他们是如何做出决定的</strong>，因此，往往不能有效地用语言表达他们自己的问题解决过程。 仔细研究详细的案例往往会发现解决方案过程中的一致模式，这些模式仍然是模糊的。 在进行深入分析时，对概念和关系的必要改进将变得明显。 此外，如果各方都同意录音，专家和客户之间的谈话录音可能会有用。 这可以识别那些通常可能被专家和扮演用户角色的知识工程师之间的受控会话忽略的要点。 它还有助于防止这一过程成为一种学术活动，并确保最终用户的需求得到满足。</p>
<p>记录关于某个主题的所有已知信息很容易，人们很容易记录关于一个主题的所有已知信息，在这个过程中忽略了最初的问题意图。 例如，为了开发一个系统来提供关于杂草控制的建议，创建一个专门识别一个地区所有可能杂草的种类的程序是很诱人的。 这将需要用户提供大量可能不必要的投入。 也许唯一相关的信息是杂草是阔叶草还是草，对于特定作物两种被批准的除草剂类型之一将被推荐使用。</p>
<p>一些 ES 开发工具具有归纳特性，允许根据专家创建的示例创建规则。 这种开发方法对于分类问题常常是有用的。 神经网络也以类似的方式运行，将在以后的作业中进行探讨。</p>
<h2 id="形式化"><a href="#形式化" class="headerlink" title="形式化"></a>形式化</h2><p>形式化包括将关键概念、子问题和信息流组织成形式化表示。 实际上，程序逻辑是在这个阶段设计的。 对收集到的知识进行分组或模块化通常很有用，甚至可以尝试以图形化的方式显示解决问题的步骤。<br>实际上，知识工程师的工作就是构建一组相关的树结构来表示知识库。 他们必须决定用来解决问题的属性，然后这些属性中的哪些应该向用户询问或者用一组内部决策树来表示。 虽然决策树的简单性很吸引人，并且是将知识形式化为可视化知识表示方案的好方法，但事情在实践中很少这么简单，<strong>严格遵守树型结构也很少令人满意</strong>。</p>
<p>知识的表示对于用户的可信度和接受度非常重要。所提出的问题和所审查的规则应与人类专家所使用的顺序相同。通过向专家提供几个详细的场景来确定问题及其顺序。概念的粒度和结构，包括概念如何关联到逻辑流以及不确定性如何涉及，在提出建议时是相互协调的。</p>
<p>对问题域进行分析，以发现决策过程中可能存在的模糊的行为模型和数学模型。 所需信息的特征得到了确认。 因此，随着对不确定性的界定和解释，所涉及的关系会得到更好的理解，最终可以用更便捷的方式利用传统的方案编制技术加以解释。 相应地，程序开发过程作为一个知识收集器发挥作用，可用于探索被理解甚少的关系。</p>
<p>很难将概念化阶段与形式化阶段分离开来，实际上，知识库设计几乎与知识获取并行进行。 在形式化阶段最重要的两个项目是: (1)将知识片段细化为它们特定的关系和层次结构; (2)更准确地确定预期的用户与系统的交互。</p>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>在接下来的实现阶段，形式化的知识被映射或编码到开发工具的框架中，从而构建一个工作原型。 将前几个阶段建立的知识结构、推理规则和控制策略的内容组织成适当的格式。 通常，知识工程师会使用程序开发工具来构建一个工作原型，用于记录和组织在正式化阶段收集的信息，以便在这个阶段完成实施。 如果没有，早期阶段的记录就会在这个时候被编码。</p>
<p>必须考虑到长期的维护。 随着时间的推移，必须预料到对知识库的修改。 对知识库进行编码时，应该对其进行广泛的文档化。 应尽可能减少以后可能出现的误解和混乱。 此外，还应包括广泛的理由和解释，以帮助最终用户充分理解程序向他们提出的问题，以便用户能够有效地使用程序输出，并根据需要向用户显示建议是如何在逻辑上得出的。</p>
<p>将纳入的帮助的数量将取决于预期用户的能力。 虽然顾问可能有兴趣迅速得到一个问题的答案，但那些必须完成建议的人打算使用的专家系统是不同的。 通常，为了相信建议，最终用户需要了解建议所依据的假设，并希望为程序建议提供可信的理由。</p>
<p>这也是开发人员必须决定程序如何与其他计算机程序和数据库交互的地方。 第一代专家系统是独立的程序。 许多操作系统没有与操作系统通信的功能，也没有读取或写入数据库的功能。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>最后一个阶段，测试，涉及的不仅仅是查找和修复语法错误。 它包括个人关系的验证，程序性能的验证和软件包效用的评估。 测试指导重新制定的概念，重新设计表述和其他细化。 验证及确认必须在整个开发过程中发生。 验证证明程序中的模型是真实的关系。 通过让领域专家操作程序以应对所有可能的意外情况，可以确保知识被准确地模仿。</p>
<p>也许测试最困难的方面是准确地处理不确定性，这种不确定性以这样或那样的方式包含在大多数专家系统中。 确定性因子是处理不确定性最常用的方法之一。 核查分配给知识库的确定性因素主要是一个反复试验的过程，由领域专家改进初步估计，直到方案始终以满足专家的确定性水平提供建议。 为了确保程序的准确性，必须仔细评估所有可能的解决方案路径。</p>
<p>一个有效的验证程序对于项目的成功和被接受是至关重要的。 在验证过程中，需要关注以下几个方面: (1)规则的正确性、一致性和完整性; (2)控制策略按照与解决问题过程相对应的顺序考虑信息的能力; (3)关于如何得出结论和为什么需要某些信息的信息是否恰当; 以及最关键的是，(4)计算机程序输出与领域专家的相应解决方案是否一致。</p>
<p>如何向最终用户提出问题和输出的顺序可能与接受和使用以及建议的准确性有同样大的关系。 如果项目要取得成功，人类工程学的经验教训是不容忽视的。</p>
<p>验证是一个持续的过程，要求针对特定用户的输出建议是准确的。 通过允许其他人严格审查并提出改进建议，验证得到了加强。 正式的项目评估有助于确定系统是否达到预期的初始目标。 评价过程侧重于发现问题的可信性、可接受性和实用性。 这可以通过程序的准确性来确定，而程序的准确性是通过与实际环境的比较确定的。 包括对程序的理解和灵活性、易用性、设计的适应性以及解决方案的正确性。</p>
<hr>
<p>Waterman, D.A. 1986. A guide to expert systems. Addison-Wesley Publishing Co., Inc., Reading, MA.</p>
]]></content>
      <categories>
        <category>专家系统</category>
      </categories>
      <tags>
        <tag>专家系统</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>如何分析自己的心理问题</title>
    <url>/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BF%83%E7%90%86%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="了解你的问题"><a href="#了解你的问题" class="headerlink" title="了解你的问题"></a>了解你的问题</h1><p>您必须了解您正在经历的事件、问题或者说是现象，然后才能实际地尝试找出解决它的办法。 请按照步骤来了解一个问题的本质。 当心任何你可能将问题外部化的倾向(例如，从别人的行为而不是你自己的行为来找出问题的原因)。 承认自己对制造或维护问题负有的任何责任。</p>
<p>理解你的问题需要你花一些时间来确定你的问题的本质。什么可能导致这个问题，为什么以及怎么会成为你的问题。 因为心理健康和生活问题通常是令人不安和焦虑的，当思考它们的时候会有一种情绪化倾向。 当你变得情绪化时，很容易被自我防御的感觉分心或愚弄，也很容易根据错误的认知行事。 在你在恐慌中逃避问题的时候，你可能会不恰当地轻视它(得出结论认为它不是一个真正的问题) ，或者夸大它(小题大做)。 你可能不愿意承认自己在制造或维持这个问题中所扮演的角色，相反，你不适当地把自己的失败归咎于他人。 仔细思考你的问题的本质，而不是仅仅按照你的第一印象或冲动行事。 如果可能的话，和你信任的人谈谈你的问题，以获得他们(希望没有偏见)的观点。 尽量放松，诚实，不要为自己的处境辩护。 放开你的情绪(焦虑、抑郁、恐慌等等，当你思考和阅读你的问题时(尽可能多地完成这个任务)会帮助你了解你是否真的有动力去改变，以及是否寻求专业的帮助比尝试自助方法更好。</p>
<p>鲍勃认识到了他的愤怒和愤怒的原因(例如，山姆借了工具箱，但他说他会还的时候却不还)。 他还对自己承认，他仍然对过去的萨姆很生气，向他借了东西，而那几次他没有对萨姆表达感谢。</p>
<h1 id="将问题分解为小部分"><a href="#将问题分解为小部分" class="headerlink" title="将问题分解为小部分"></a>将问题分解为小部分</h1><p>即使你知道你的问题是什么，它可能太大，太成熟了，你无法一下子解决所有问题。与其一次性解决所有问题，不如将其分解成可管理的部分。然后，制定一个计划，如何分别解决每个部分。<br>例子:因为鲍勃知道他确实能控制住自己的怒火，所以他和山姆谈了谈，而且他仍然珍惜和山姆的友谊，所以他决定和他谈谈借东西的事，而不是对他大吼大叫或打架。在这种情况下，鲍勃正在发挥自己的优势;他能与萨姆交谈，即使在生气的时候也能理智而冷静地与之交谈，同时也能意识到并尊重他对萨姆的友谊。尽管这个例子并不是一个非常复杂的问题，Sam仍然花时间将问题分解为多个单独的部分。他需要想办法1)停止沮丧，2)拿回他的工具，3)如果可能的话保持他和山姆的关系。把他不同的目标和愿望分开考虑，就能帮助他决定如何最好地处理这种情况。如果还需要采取更多措施，同样的知识将继续阐明他下一步应该采取什么行动。</p>
<h1 id="给出每个问题的目标"><a href="#给出每个问题的目标" class="headerlink" title="给出每个问题的目标"></a>给出每个问题的目标</h1><p>对于你的每一个小的可处理的问题部分，弄清楚你的目标是什么; 你希望在每一个问题部分的自助过程结束时达到什么程度。 如果你不知道你在朝着什么方向努力，你永远不会知道你什么时候到达那里。</p>
<p>例如: 鲍勃已经确定了三个目标: 1)停止他对萨姆的愤怒所造成的痛苦; 2)按时从萨姆那里拿回工具箱; 3)保持与萨姆的友谊。</p>
<h1 id="衡量实现目标的进度"><a href="#衡量实现目标的进度" class="headerlink" title="衡量实现目标的进度"></a>衡量实现目标的进度</h1><p>找到一些方法来衡量你在实现每个问题目标的过程中所取得的进步，这样你就能总是知道: 1)你的问题起点是什么样的; 2)你在任何特定时刻距离实现目标还有多远; 3)你如何知道什么时候你已经实现了你的目标并且完成了。<br>鲍勃第一次有机会衡量他在实现目标方面所取得的进展是在他和萨姆谈话的时候。 不管山姆是否对鲍勃感到不满，鲍勃都无法控制，所以鲍勃无法通过山姆的反应来合理地衡量他的成功。 取而代之，如果他能够以一种清晰、冷静和坚定的方式说出他想说的话，同时尽力不疏远他的朋友，他用这些来衡量自己是否达到了目标。 Sam 是否返回丢失的工具箱，对 Bob 来说是另一个衡量他与 Sam 沟通成功与否的机会。 Bob 可以监控 Sam 在未来按时归还借来的工具方面的表现。 如果这些活动中有任何一个不顺利，那么鲍勃就会知道他不需要借给山姆任何他自己特别需要的东西。</p>
<p> 原文：<a href="https://www.mentalhelp.net/self-help/steps-1-4-problem-analysis/" target="_blank" rel="noopener">Steps 1-4: Problem Analysis</a></p>
]]></content>
      <categories>
        <category>心理</category>
      </categories>
      <tags>
        <tag>自助</tag>
        <tag>心理</tag>
      </tags>
  </entry>
</search>
